---
title: "R_attack"
author: "Minajia ZHU"
date: "Tuesday, January 20, 2015"
output: html_document
---


```{r,echo=FALSE,warning=FALSE}
options(xtable.comment = FALSE)
library("knitr")
opts_chunk$set(message=F,comment="",tidy=T,warning=FALSE,highlight=TRUE)

```



## 备注

1.读取任何形式的数据(包括mp3数据):

> G:\R\datascience\Getting and Cleaning Data\quiz2

----

## lattice

```{r}
library(lattice)
## Convert 'Month' to a factor variable
airquality <- transform(airquality, Month = factor(Month))
xyplot(Ozone ~ Wind | Month, data = airquality, layout = c(5, 1))

```

```{r}
set.seed(10)
x <- rnorm(100)
f <- rep(0:1, each = 50)
y <- x + f - f * x + rnorm(100, sd = 0.5)
f <- factor(f, labels = c("Group 1", "Group 2"))
xyplot(y ~ x | f, layout = c(2, 1))  ## Plot with 2 panels
```

```{r}
## Custom panel function
xyplot(y ~ x | f, panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)  ## First call the default panel function for 'xyplot'
    panel.abline(h = median(y), lty = 2)  ## Add a horizontal line at the median
})

## Custom panel function
xyplot(y ~ x | f, panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)  ## First call default panel function
    panel.lmline(x, y, col = 2)  ## Overlay a simple linear regression line
})
```

----------
## 数据操作

### 基础

```{r}

rep(1:5,each = 2)
rep(1:5,time = 2)
seq(1,10,by = 2)
seq(1,10,lentgh = 3)

```

```{r}
attributes(airquality)
attr(airquality,"row.names")
```

```{r}
#检验两组向量是否都为完整的
 x <- c(1, 2, NA, 4, NA, 5)
 y <- c("a", "b", NA, "d", "e",NA)
complete.cases(x,y)

 airquality[1:6, ]
good <- complete.cases(airquality)
 airquality[good, ][1:6, ]
```




```{r}

set.seed(13435)
X <- data.frame("var1"=sample(1:5),"var2"=sample(6:10),"var3"=sample(11:15))
X <- X[sample(1:5),]; X$var2[c(1,3)] = NA
X[(X$var1 <= 3 | X$var3 > 15),]

# 用which不会产生NA
X[1:2,"var2"]
X[which(X$var2 > 8),]

sort(X$var2,na.last=TRUE)
X[order(X$var1,X$var3),]

```

```{r}

library(plyr)
arrange(X,var1)
arrange(X,desc(var1))

X$var4 <- rnorm(5)
Y <- cbind(X,rnorm(5))

```



----------

Writing for, while loops is useful when programming but not particularly easy when working interactively on the command line. There are some functions which implement looping to make life easier.

* lapply: Loop over a list and evaluate a function on each element
* sapply: Same as lapply but try to simplify the result
* apply: Apply a function over the margins of an array
* tapply: Apply a function over subsets of a vector
* mapply: Multivariate version of lapply

An auxiliary function split is also useful, particularly in conjunction with lapply.


### example:

### sapply

```{r}
x <- 1:4
lapply(x, runif, min = 0, max = 10)

x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 
lapply(x, function(elt) elt[,1])
```


### mapply

```{r}
noise <- function(n, mean, sd) {
 rnorm(n, mean, sd)
 }
noise(5, 1, 2)
mapply(noise, 1:5, 1:5, 2)
```

### tapply

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
f
tapply(x, f, mean)
```

### split

```{r}
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],
                                 na.rm = TRUE))


```

