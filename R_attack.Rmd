---
title: "R_attack"
author: "Minajia ZHU"
date: "Tuesday, January 20, 2015"
output: html_document
---


```{r,echo=FALSE,warning=FALSE}
options(xtable.comment = FALSE)
library("knitr")
library("formatR")
opts_chunk$set(message=F,comment="",tidy=T,warning=FALSE,highlight=TRUE)

```



## 备注

1.读取任何形式的数据(包括mp3数据):

> G:\\R\\datascience\\Getting and Cleaning Data\\quiz2

2.展示数据结构和概况:

> ls.files() 
ls.str()

```{r}
summary(airquality)
str(airquality)
attributes(airquality)
attr(airquality,"row.names")
```

3.
```{r}
x = c(1,2,"cat",3);x
mode(x)
y = c(5,T,3,7);y
mode(y)

```

4.全局设置

```{r}
names(options())

```

5.保存变量和读取变量

```
#前者保存全部变量，后者保存指定变量
save.image()
save(变量x,变量y,变量z, file = "mydata.rda")
load("mydata.rda")

```

6.输入与输出

```
#文本输出
sink("test.txt",append = T, SPLIT = T)
#图片输出
pdf("test.pdf"")
    
head(CO2)
dev.off()

write.table(CO2,file = "co2.txt", row.names = F,col.names = F,sep = ",")

#从其他程序读取数据,采用foreign包

```


---------------

## lattice

```{r}
library(lattice)
## Convert 'Month' to a factor variable
airquality <- transform(airquality, Month = factor(Month))
xyplot(Ozone ~ Wind | Month, data = airquality, layout = c(5, 1))

```

```{r}
set.seed(10)
x <- rnorm(100)
f <- rep(0:1, each = 50)
y <- x + f - f * x + rnorm(100, sd = 0.5)
f <- factor(f, labels = c("Group 1", "Group 2"))
xyplot(y ~ x | f, layout = c(2, 1))  ## Plot with 2 panels
```

```{r}
## Custom panel function
xyplot(y ~ x | f, panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)  ## First call the default panel function for 'xyplot'
    panel.abline(h = median(y), lty = 2)  ## Add a horizontal line at the median
})

## Custom panel function
xyplot(y ~ x | f, panel = function(x, y, ...) {
    panel.xyplot(x, y, ...)  ## First call default panel function
    panel.lmline(x, y, col = 2)  ## Overlay a simple linear regression line
})
```

----------

## 数据操作

### 基础

**简单的数据生成**

```{r}

rep(1:5,each = 2)
rep(1:5,time = 2)
seq(1,10,by = 2)
seq(1,10,length = 3)

```

**生成因子**

```{r}
#gl(x,y) x为所需生成不同因子的数目，y为重复的次数

thelevels = data.frame(group=gl(3,10,length=30),
       subgroup=gl(5,2,length=30),
       obs=gl(2,1,length=30))

#第一个因子乘以第二个因子

expand.grid(seq(1,5,by = 2),seq(2,5,by = 2))
```


**序列的处理**

```{r}
#rle()为游程处理
seq1 = c(1,3,5,2,4,2,2,2,7,6)
rle.seq1 = rle(seq1)
rle.seq1
any(rle.seq1$values == 2 & rle.seq1$length >= 3)

```



**读取数据**

```
options(stringsAsFactors = F)
read.table(file, col.names = c(), row.names = NULL, as.is = 索引向量(哪些变量不被转换成因子) / 与变量长度相符的逻辑向量 / TRUE(全部不转换),
 na.strings = , comment.char = '', encoding = 其他字符, skip = , nrows = 想要读取的行数 ,fill = TRUE(用count.fields来确定问题所在), 
 colClasses = 字符向量 / "NULL"指跳过某列 / NA指默认设置)

注意:若要读取相同宽度的不规则数据,使用read.fwf函数
```

```
library(RODBC)
z <− odbcConnectExcel ( ”.xls” )
dd <− sqlFetch ( z , ” Sheet1 ” )
close(z)

```



**矩阵**

```{r}

rmat = matrix(rnorm(15),5,3,dimnames = list(NULL,c('A','B','C'))) 
rmat

# 或者

rmat = matrix(rnorm(15),5,3)
dimnames(rmat) = list(NULL,c('A','B','C'))
rmat
```



**检验两组向量是否都为完整的**
```{r}

 x <- c(1, 2, NA, 4, NA, 5)
 y <- c("a", "b", NA, "d", "e",NA)
complete.cases(x,y)

 airquality[1:6, ]
good <- complete.cases(airquality)
 airquality[good, ][1:6, ]
```

**缺失值的处理**

```
x[!is.na(x)]
na.omit()
对于统计慨括函数,mean,var等,可使用参数na.rm = T
```


```{r}

set.seed(13435)
X <- data.frame("var1"=sample(1:5),"var2"=sample(6:10),"var3"=sample(11:15))
X <- X[sample(1:5),]; X$var2[c(1,3)] = NA
X[(X$var1 <= 3 | X$var3 > 15),]

X[1:2,"var2"]
X[which(X$var2 > 8),]

sort(X$var2,na.last=TRUE)
X[order(X$var1,X$var3),]

```

```{r}

library(plyr)
arrange(X,var1)
arrange(X,desc(var1))

X$var4 <- rnorm(5)
Y <- cbind(X,rnorm(5))

```



----------

Writing for, while loops is useful when programming but not particularly easy when working interactively on the command line. There are some functions which implement looping to make life easier.

* lapply: Loop over a list and evaluate a function on each element
* sapply: Same as lapply but try to simplify the result
* apply: Apply a function over the margins of an array
* tapply: Apply a function over subsets of a vector
* mapply: Multivariate version of lapply

An auxiliary function split is also useful, particularly in conjunction with lapply.


### example:

### sapply

```{r}
x <- 1:4
lapply(x, runif, min = 0, max = 10)

x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2)) 
lapply(x, function(elt) elt[,1])
```


### mapply

```{r}
noise <- function(n, mean, sd) {
 rnorm(n, mean, sd)
 }
noise(5, 1, 2)
mapply(noise, 1:5, 1:5, 2)
```

### tapply

```{r}
x <- c(rnorm(10), runif(10), rnorm(10, 1))
f <- gl(3, 10)
f
tapply(x, f, mean)
```

### split

```{r}
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")],
                                 na.rm = TRUE))


```

